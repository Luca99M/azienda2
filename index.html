-- ===========================================
-- 0) SAFE SETTINGS (facilita ri-esecuzioni)
-- ===========================================
set client_min_messages = warning;

-- ===========================================
-- 1) NORMALIZZA/ALLINEA SCHEMA ESISTENTE
--    (aggiunge colonne mancanti, NON rimuove nulla)
-- ===========================================

-- Elenco prodotti coerente col DB
-- (se in futuro aggiungi prodotti nuovi, basta aggiungerli qui e rieseguire)
create or replace function public._prodotti_elenco()
returns text[]
language sql
stable
as $$
  select array[
    'formaggio','mezza_forma','forma_stagionata','mezzaforma_stag',
    'ricotta','miele','noci_1kg','noci_3kg',
    'olio_025l','olio_05l','olio_075l','olio_1l','olio_2l','olio_3l','olio_5l',
    'grattugiato',
    'prod_17','prod_18','prod_19','prod_20','prod_21','prod_22','prod_23','prod_24','prod_25','prod_26','prod_27','prod_28','prod_29','prod_30'
  ];
$$;

-- Helper che assicura campi prodotto su una tabella "larga"
create or replace function public._ensure_prod_columns(_schema text, _table text)
returns void
language plpgsql
as $$
declare
  col text;
  sql text;
begin
  foreach col in array (select unnest(public._prodotti_elenco())) loop
    -- Aggiunge la colonna se non esiste (double precision default 0)
    sql := format('alter table if exists %I.%I add column if not exists %I double precision default 0;', _schema, _table, col);
    execute sql;
  end loop;
end;
$$;

-- -------- VENDITE (già ce l’hai: aggiungo solo se manca) --------
do $$
begin
  if not exists (
    select 1 from information_schema.tables
    where table_schema='public' and table_name='vendite'
  ) then
    execute $ct$
      create table public.vendite (
        id bigserial primary key,
        data date not null,
        ora time without time zone not null,
        operatore varchar(50) not null,
        note text null,
        importo_inserito double precision default 0,
        created_at timestamptz default now()
      );
    $ct$;
  end if;

  -- garantisce tutte le colonne prodotto
  perform public._ensure_prod_columns('public','vendite');

  -- indici utili
  create index if not exists idx_vendite_data on public.vendite (data);
  create index if not exists idx_vendite_operatore on public.vendite (operatore);
  create index if not exists idx_vendite_created_at on public.vendite (created_at);
  create index if not exists idx_vendite_data_ora on public.vendite (data, ora);
end;
$$;

-- -------- FATTURATO (sottrae magazzino) --------
do $$
begin
  if not exists (
    select 1 from information_schema.tables
    where table_schema='public' and table_name='fatturato'
  ) then
    execute $ct$
      create table public.fatturato (
        id bigserial primary key,
        data date not null,
        ora time without time zone not null,
        operatore varchar(50) not null,
        fatturatore varchar(120),
        note text,
        importo_inserito double precision default 0,
        created_at timestamptz default now()
      );
    $ct$;
  end if;

  perform public._ensure_prod_columns('public','fatturato');

  create index if not exists idx_fatturato_data on public.fatturato (data);
  create index if not exists idx_fatturato_operatore on public.fatturato (operatore);
  create index if not exists idx_fatturato_created_at on public.fatturato (created_at);
  create index if not exists idx_fatturato_data_ora on public.fatturato (data, ora);
end;
$$;

-- -------- PRODOTTI_AGGIUNTI (aggiunge magazzino) --------
do $$
begin
  if not exists (
    select 1 from information_schema.tables
    where table_schema='public' and table_name='prodotti_aggiunti'
  ) then
    execute $ct$
      create table public.prodotti_aggiunti (
        id bigserial primary key,
        data date not null,
        ora time without time zone not null,
        operatore varchar(50) not null,
        note text,
        created_at timestamptz default now()
      );
    $ct$;
  end if;

  perform public._ensure_prod_columns('public','prodotti_aggiunti');

  create index if not exists idx_prodotti_aggiunti_data on public.prodotti_aggiunti (data);
  create index if not exists idx_prodotti_aggiunti_operatore on public.prodotti_aggiunti (operatore);
  create index if not exists idx_prodotti_aggiunti_created_at on public.prodotti_aggiunti (created_at);
  create index if not exists idx_prodotti_aggiunti_data_ora on public.prodotti_aggiunti (data, ora);
end;
$$;

-- -------- PRODUZIONE_CELLA_FRIGO (solo forme fresche prodotte) --------
create table if not exists public.produzione_cella_frigo (
  id bigserial primary key,
  data date not null,
  ora time without time zone not null,
  operatore varchar(50) not null,
  forme double precision not null default 0,  -- numero di forme fresche prodotte
  note text,
  created_at timestamptz default now()
);
create index if not exists idx_produzione_data on public.produzione_cella_frigo (data, ora);

-- ===========================================
-- 2) VISTA MOVIMENTI UNIFICATI (UNPIVOT)
--    Converte mezze-forme in 0.5 della forma equivalente
-- ===========================================
create or replace view public.v_movimenti_unificati as
with prodotti as (
  select unnest(public._prodotti_elenco()) as prodotto
)
-- PRODOTTI_AGGIUNTI (+)
select
  'prodotti_aggiunti'::text as fonte,
  pa.id,
  pa.data,
  pa.ora,
  pa.operatore,
  p.prodotto,
  case
    when p.prodotto='mezza_forma'
      then coalesce( (to_jsonb(pa)->>p.prodotto)::double precision, 0 ) * 0.5
    when p.prodotto='mezzaforma_stag'
      then coalesce( (to_jsonb(pa)->>p.prodotto)::double precision, 0 ) * 0.5
    else coalesce( (to_jsonb(pa)->>p.prodotto)::double precision, 0 )
  end as quantita_equivalente,
  case
    when p.prodotto='mezza_forma' then 'formaggio'
    when p.prodotto='mezzaforma_stag' then 'forma_stagionata'
    else p.prodotto
  end as prodotto_equivalente,
  +1 as segno
from public.prodotti_aggiunti pa
cross join prodotti p

union all
-- PRODUZIONE CELLA FRIGO (+) su "formaggio"
select
  'produzione_cella_frigo' as fonte,
  pr.id, pr.data, pr.ora, pr.operatore,
  'formaggio' as prodotto,
  pr.forme::double precision as quantita_equivalente,
  'formaggio' as prodotto_equivalente,
  +1 as segno
from public.produzione_cella_frigo pr

union all
-- VENDITE (−)
select
  'vendite' as fonte,
  v.id, v.data, v.ora, v.operatore,
  p.prodotto,
  case
    when p.prodotto='mezza_forma'
      then coalesce( (to_jsonb(v)->>p.prodotto)::double precision, 0 ) * 0.5
    when p.prodotto='mezzaforma_stag'
      then coalesce( (to_jsonb(v)->>p.prodotto)::double precision, 0 ) * 0.5
    else coalesce( (to_jsonb(v)->>p.prodotto)::double precision, 0 )
  end as quantita_equivalente,
  case
    when p.prodotto='mezza_forma' then 'formaggio'
    when p.prodotto='mezzaforma_stag' then 'forma_stagionata'
    else p.prodotto
  end as prodotto_equivalente,
  -1 as segno
from public.vendite v
cross join prodotti p

union all
-- FATTURATO (−)
select
  'fatturato' as fonte,
  f.id, f.data, f.ora, f.operatore,
  p.prodotto,
  case
    when p.prodotto='mezza_forma'
      then coalesce( (to_jsonb(f)->>p.prodotto)::double precision, 0 ) * 0.5
    when p.prodotto='mezzaforma_stag'
      then coalesce( (to_jsonb(f)->>p.prodotto)::double precision, 0 ) * 0.5
    else coalesce( (to_jsonb(f)->>p.prodotto)::double precision, 0 )
  end as quantita_equivalente,
  case
    when p.prodotto='mezza_forma' then 'formaggio'
    when p.prodotto='mezzaforma_stag' then 'forma_stagionata'
    else p.prodotto
  end as prodotto_equivalente,
  -1 as segno
from public.fatturato f
cross join prodotti p
where
  -- tieni solo movimenti con quantità > 0 (evita righe inutili)
  case
    when p.prodotto in ('mezza_forma','mezzaforma_stag')
      then coalesce( (to_jsonb(case fonte
                                 when 'prodotti_aggiunti' then (select pa)
                                 when 'vendite' then (select v)
                                 when 'fatturato' then (select f)
                               end)->>p.prodotto)::double precision, 0 ) * 0.5
    else coalesce( (to_jsonb(case fonte
                               when 'prodotti_aggiunti' then (select pa)
                               when 'vendite' then (select v)
                               when 'fatturato' then (select f)
                             end)->>p.prodotto)::double precision, 0 )
  end > 0;

-- ===========================================
-- 3) VISTA INVENTARIO ISTANTANEO
-- ===========================================
create or replace view public.v_magazzino as
select
  prodotto_equivalente as prodotto,
  sum(quantita_equivalente * segno) as giacenza
from public.v_movimenti_unificati
group by prodotto_equivalente
order by prodotto_equivalente;

-- ===========================================
-- 4) INVENTARIO GIORNALIERO (saldo a fine giorno)
-- ===========================================
-- Per ogni data e prodotto, calcola il delta e poi fa la cumulata
create or replace view public.v_magazzino_giornaliero as
with delta as (
  select data, prodotto_equivalente as prodotto,
         sum(quantita_equivalente * segno) as d
  from public.v_movimenti_unificati
  group by data, prodotto_equivalente
),
days as (
  -- Elenco completo delle date presenti
  select distinct data from (
    select data from public.v_movimenti_unificati
  ) s
),
grid as (
  -- Prodotto × Giorno (per colmare i buchi)
  select p.prodotto, d.data
  from (select distinct prodotto_equivalente as prodotto from public.v_movimenti_unificati) p
  cross join days d
)
select
  g.data,
  g.prodotto,
  sum(coalesce(d.d,0)) over (partition by g.prodotto order by g.data
                             rows between unbounded preceding and current row) as giacenza_giorno
from grid g
left join delta d
  on d.prodotto = g.prodotto and d.data = g.data
order by g.prodotto, g.data;

-- ===========================================
-- 5) MATERIALIZED VIEW (OPZIONALE) + REFRESH
--    (più veloce per dashboard)
-- ===========================================
drop materialized view if exists public.mv_magazzino;
create materialized view public.mv_magazzino as
select * from public.v_magazzino
with no data;

-- indice per letture veloci
create index if not exists idx_mv_magazzino_prodotto on public.mv_magazzino (prodotto);

-- funzione di refresh semplice
create or replace function public.refresh_mv_magazzino()
returns void
language plpgsql
as $$
begin
  refresh materialized view public.mv_magazzino;
end;
$$;

-- trigger leggeri per aggiornare la MV dopo scritture
-- (se i volumi sono alti, valuta di disabilitarli e fare refresh schedulato)
drop trigger if exists trg_refresh_mv_vendite on public.vendite;
create trigger trg_refresh_mv_vendite
after insert or update or delete on public.vendite
for each statement
execute function public.refresh_mv_magazzino();

drop trigger if exists trg_refresh_mv_fatturato on public.fatturato;
create trigger trg_refresh_mv_fatturato
after insert or update or delete on public.fatturato
for each statement
execute function public.refresh_mv_magazzino();

drop trigger if exists trg_refresh_mv_aggiunti on public.prodotti_aggiunti;
create trigger trg_refresh_mv_aggiunti
after insert or update or delete on public.prodotti_aggiunti
for each statement
execute function public.refresh_mv_magazzino();

drop trigger if exists trg_refresh_mv_produzione on public.produzione_cella_frigo;
create trigger trg_refresh_mv_produzione
after insert or update or delete on public.produzione_cella_frigo
for each statement
execute function public.refresh_mv_magazzino();

-- ===========================================
-- 6) RPC per il FRONT-END (Supabase)
--    (esponi queste come "rest" direttamente)
-- ===========================================

-- 6.1) Inventario istantaneo
create or replace function public.get_magazzino()
returns table(prodotto text, giacenza double precision)
language sql
stable
as $$
  select prodotto, giacenza from public.v_magazzino;
$$;

-- 6.2) Inventario al giorno X (fine giornata)
create or replace function public.get_magazzino_giorno(p_data date)
returns table(prodotto text, giacenza_giorno double precision)
language sql
stable
as $$
  with last as (
    select prodotto, max(data) as last_date
    from public.v_magazzino_giornaliero
    where data <= p_data
    group by prodotto
  )
  select g.prodotto, g.giacenza_giorno
  from public.v_magazzino_giornaliero g
  join last l on l.prodotto = g.prodotto and l.last_date = g.data
  order by g.prodotto;
$$;

-- 6.3) Movimenti filtrabili (per tabella movimenti)
create or replace function public.get_movimenti(
  p_da date default null,
  p_a  date default null,
  p_prodotto text default null,
  p_fonte text default null,      -- 'vendite' | 'fatturato' | 'prodotti_aggiunti' | 'produzione_cella_frigo'
  p_operatore text default null
)
returns table(
  fonte text,
  id bigint,
  data date,
  ora time without time zone,
  operatore text,
  prodotto text,
  quantita_equivalente double precision,
  segno int
)
language sql
stable
as $$
  select
    fonte, id, data, ora, operatore,
    prodotto_equivalente as prodotto,
    quantita_equivalente, segno
  from public.v_movimenti_unificati
  where (p_da is null or data >= p_da)
    and (p_a  is null or data <= p_a)
    and (p_prodotto is null or prodotto_equivalente = p_prodotto)
    and (p_fonte    is null or fonte = p_fonte)
    and (p_operatore is null or operatore = p_operatore)
  order by data desc, ora desc, fonte, prodotto;
$$;

-- ===========================================
-- 7) QUICK TESTS (puoi commentarli)
-- ===========================================
-- select * from public.v_magazzino;
-- select * from public.get_magazzino();
-- select * from public.get_magazzino_giorno(current_date);
-- select * from public.get_movimenti(p_da => current_date - 7);
